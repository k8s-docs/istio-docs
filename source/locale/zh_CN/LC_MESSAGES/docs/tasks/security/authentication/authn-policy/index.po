# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, BandCamp
# This file is distributed under the same license as the istio-docs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: istio-docs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-03-22 10:08+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:2
msgid "authn-policy"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:4
msgid ""
"This task covers the primary activities you might need to perform when "
"enabling, configuring, and using Istio authentication policies. Find out "
"more about the underlying concepts in the `authentication overview "
"</docs/concepts/security/#authentication>`_."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:10
msgid "Before you begin"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:12
msgid ""
"Understand Istio `authentication policy </docs/concepts/security"
"/#authentication-policies>`_ and related `mutual TLS authentication "
"</docs/concepts/security/#mutual-tls-authentication>`_ concepts."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:18
msgid ""
"Install Istio on a Kubernetes cluster with the ``default`` configuration "
"profile, as described in `installation steps </docs/setup/getting-"
"started>`_."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:27
msgid "Setup"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:29
msgid ""
"Our examples use two namespaces ``foo`` and ``bar``, with two services, "
"``httpbin`` and ``sleep``, both running with an Envoy proxy. We also use "
"second instances of ``httpbin`` and ``sleep`` running without the sidecar"
" in the ``legacy`` namespace. If you’d like to use the same examples when"
" trying the tasks, run the following:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:38
msgid ""
"kube-inject -f @samples/httpbin/httpbin.yaml@) -n foo $ kubectl apply -f "
"<(istioctl kube-inject -f @samples/sleep/sleep.yaml@) -n foo $ kubectl "
"create ns bar $ kubectl apply -f <(istioctl kube-inject -f "
"@samples/httpbin/httpbin.yaml@) -n bar $ kubectl apply -f <(istioctl "
"kube-inject -f @samples/sleep/sleep.yaml@) -n bar $ kubectl create ns "
"legacy $ kubectl apply -f @samples/httpbin/httpbin.yaml@ -n legacy $ "
"kubectl apply -f @samples/sleep/sleep.yaml@ -n legacy"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:46
msgid ""
"You can verify setup by sending an HTTP request with ``curl`` from any "
"``sleep`` pod in the namespace ``foo``, ``bar`` or ``legacy`` to either "
"``httpbin.foo``, ``httpbin.bar`` or ``httpbin.legacy``. All requests "
"should succeed with HTTP code 200."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:51
msgid ""
"For example, here is a command to check ``sleep.bar`` to ``httpbin.foo`` "
"reachability:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:57
msgid ""
"-o jsonpath={.items..metadata.name}) -c sleep -n bar – curl "
"http://httpbin.foo:8000/ip -s -o /dev/null -w “%{http_code}:raw-"
"latex:`\\n`” 200"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:61
msgid ""
"This one-liner command conveniently iterates through all reachability "
"combinations:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:67
msgid ""
"“bar” “legacy”; do kubectl exec $(kubectl get pod -l app=sleep -n ${from}"
" -o jsonpath={.items..metadata.name}) -c sleep -n :math:`{from} -- curl "
"\"http://httpbin.`\\ {to}:8000/ip\" -s -o /dev/null -w “sleep.\\ "
":math:`{from} to httpbin.`\\ {to}: %{http_code}:raw-latex:`\\n`”; done; "
"done sleep.foo to httpbin.foo: 200 sleep.foo to httpbin.bar: 200 "
"sleep.foo to httpbin.legacy: 200 sleep.bar to httpbin.foo: 200 sleep.bar "
"to httpbin.bar: 200 sleep.bar to httpbin.legacy: 200 sleep.legacy to "
"httpbin.foo: 200 sleep.legacy to httpbin.bar: 200 sleep.legacy to "
"httpbin.legacy: 200"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:77
msgid ""
"Verify there is no peer authentication policy in the system with the "
"following command:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:83
msgid "resources found."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:85
msgid ""
"Last but not least, verify that there are no destination rules that apply"
" on the example services. You can do this by checking the ``host:`` value"
" of existing destination rules and make sure they do not match. For "
"example:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:93
msgid "–all-namespaces -o yaml \\| grep “host:”"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:97
msgid "Depending on the version of Istio, you may see destination"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:98
msgid ""
"rules for hosts other then those shown. However, there should be none "
"with hosts in the ``foo``, ``bar`` and ``legacy`` namespace, nor is the "
"match-all wildcard ``*``"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:103
msgid "Auto mutual TLS"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:105
msgid ""
"By default, Istio tracks the server workloads migrated to Istio proxies, "
"and configures client proxies to send mutual TLS traffic to those "
"workloads automatically, and to send plain text traffic to workloads "
"without sidecars."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:110
msgid ""
"Thus, all traffic between workloads with proxies uses mutual TLS, without"
" you doing anything. For example, take the response from a request to "
"``httpbin/header``. When using mutual TLS, the proxy injects the ``X"
"-Forwarded-Client-Cert`` header to the upstream request to the backend. "
"That header’s presence is evidence that mutual TLS is used. For example:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:120
msgid ""
"-o jsonpath={.items..metadata.name}) -c sleep -n foo – curl "
"http://httpbin.foo:8000/headers -s \\| grep X-Forwarded-Client-Cert “X"
"-Forwarded-Client-Cert”: "
"“By=spiffe://cluster.local/ns/foo/sa/httpbin;Hash=”"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:125
msgid ""
"When the server doesn’t have sidecar, the ``X-Forwarded-Client-Cert`` "
"header is not there, which implies requests are in plain text."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:131
msgid ""
"-o jsonpath={.items..metadata.name}) -c sleep -n foo – curl "
"http://httpbin.legacy:8000/headers -s \\| grep X-Forwarded-Client-Cert"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:136
msgid "Globally enabling Istio mutual TLS in STRICT mode"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:138
msgid ""
"While Istio automatically upgrades all traffic between the proxies and "
"the workloads to mutual TLS between, workloads can still receive plain "
"text traffic. To prevent non-mutual TLS for the whole mesh, set a mesh-"
"wide peer authentication policy to set mutual TLS mode to ``STRICT``. The"
" mesh-wide peer authentication policy shouldn’t have a ``selector`` "
"section, and it must apply to the **root namespace**, for example:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:149
msgid ""
"“security.istio.io/v1beta1” kind: “PeerAuthentication” metadata: name: "
"“default” namespace: “istio-system” spec: mtls: mode: STRICT EOF"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:154
msgid "The example assumes ``istio-system`` is the root namespace."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:155
msgid ""
"If you used a different value during your installation, replace ``istio-"
"system`` with the value you used."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:158
msgid ""
"This peer authentication policy has the following effects: - It "
"configures all workloads in the mesh to only accept requests encrypted "
"with TLS. Since it doesn’t specify a value for the ``selector`` field, "
"the policy applies to all workloads in the mesh."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:163
msgid "Run the test command again:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:168
msgid ""
"“bar” “legacy”; do kubectl exec $(kubectl get pod -l app=sleep -n ${from}"
" -o jsonpath={.items..metadata.name}) -c sleep -n :math:`{from} -- curl "
"\"http://httpbin.`\\ {to}:8000/ip\" -s -o /dev/null -w “sleep.\\ "
":math:`{from} to httpbin.`\\ {to}: %{http_code}:raw-latex:`\\n`”; done; "
"done sleep.foo to httpbin.foo: 200 sleep.foo to httpbin.bar: 200 "
"sleep.foo to httpbin.legacy: 200 sleep.bar to httpbin.foo: 200 sleep.bar "
"to httpbin.bar: 200 sleep.bar to httpbin.legacy: 200 sleep.legacy to "
"httpbin.foo: 000 command terminated with exit code 56 sleep.legacy to "
"httpbin.bar: 000 command terminated with exit code 56 sleep.legacy to "
"httpbin.legacy: 200"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:179
msgid ""
"You see requests still succeed, except for those from the client that "
"doesn’t have proxy, ``sleep.legacy``, to the server with a proxy, "
"``httpbin.foo`` or ``httpbin.bar``. This is expected because mutual TLS "
"is now strictly required, but the workload without sidecar cannot comply."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:186
msgid "Cleanup part 1"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:188
msgid ""
"Remove global authentication policy and destination rules added in the "
"session:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:194
msgid "default"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:197
msgid "Enable mutual TLS per namespace or workload"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:200
msgid "Namespace-wide policy"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:202
msgid ""
"To change mutual TLS for all workloads within a particular namespace, use"
" a namespace-wide policy. The specification of the policy is the same as "
"for a mesh-wide policy, but you specify the namespace it applies to under"
" ``metadata``. For example, the following peer authentication policy "
"enables strict mutual TLS for the ``foo`` namespace:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:211
msgid ""
"“security.istio.io/v1beta1” kind: “PeerAuthentication” metadata: name: "
"“default” namespace: “foo” spec: mtls: mode: STRICT EOF"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:214
msgid ""
"As this policy is applied on workloads in namespace ``foo`` only, you "
"should see only request from client-without-sidecar (``sleep.legacy``) to"
" ``httpbin.foo`` start to fail."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:221
msgid ""
"“bar” “legacy”; do kubectl exec $(kubectl get pod -l app=sleep -n ${from}"
" -o jsonpath={.items..metadata.name}) -c sleep -n :math:`{from} -- curl "
"\"http://httpbin.`\\ {to}:8000/ip\" -s -o /dev/null -w “sleep.\\ "
":math:`{from} to httpbin.`\\ {to}: %{http_code}:raw-latex:`\\n`”; done; "
"done sleep.foo to httpbin.foo: 200 sleep.foo to httpbin.bar: 200 "
"sleep.foo to httpbin.legacy: 200 sleep.bar to httpbin.foo: 200 sleep.bar "
"to httpbin.bar: 200 sleep.bar to httpbin.legacy: 200 sleep.legacy to "
"httpbin.foo: 000 command terminated with exit code 56 sleep.legacy to "
"httpbin.bar: 200 sleep.legacy to httpbin.legacy: 200"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:233
msgid "Enable mutual TLS per workload"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:235
msgid ""
"To set a peer authentication policy for a specific workload, you must "
"configure the ``selector`` section and specify the labels that match the "
"desired workload. However, Istio cannot aggregate workload-level policies"
" for outbound mutual TLS traffic to a service. Configure a destination "
"rule to manage that behavior."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:241
msgid ""
"For example, the following peer authentication policy and destination "
"rule enable strict mutual TLS for the ``httpbin.bar`` workload:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:247
msgid ""
"“security.istio.io/v1beta1” kind: “PeerAuthentication” metadata: name: "
"“httpbin” namespace: “bar” spec: selector: matchLabels: app: httpbin "
"mtls: mode: STRICT EOF"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:251
msgid "And a destination rule:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:256
msgid ""
"“networking.istio.io/v1alpha3” kind: “DestinationRule” metadata: name: "
"“httpbin” spec: host: “httpbin.bar.svc.cluster.local” trafficPolicy: tls:"
" mode: ISTIO_MUTUAL EOF"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:260
msgid ""
"Again, run the probing command. As expected, request from "
"``sleep.legacy`` to ``httpbin.bar`` starts failing with the same reasons."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:264
msgid ""
"{{< text plain >}} … sleep.legacy to httpbin.bar: 000 command terminated "
"with exit code 56"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:267
msgid ""
"To refine the mutual TLS settings per port, you must configure the "
"``portLevelMtls`` section. For example, the following peer authentication"
" policy requires mutual TLS on all ports, except port ``80``:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:275
msgid ""
"“security.istio.io/v1beta1” kind: “PeerAuthentication” metadata: name: "
"“httpbin” namespace: “bar” spec: selector: matchLabels: app: httpbin "
"mtls: mode: STRICT portLevelMtls: 80: mode: DISABLE EOF"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:279
msgid "As before, you also need a destination rule:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:284
msgid ""
"“networking.istio.io/v1alpha3” kind: “DestinationRule” metadata: name: "
"“httpbin” spec: host: httpbin.bar.svc.cluster.local trafficPolicy: tls: "
"mode: ISTIO_MUTUAL portLevelSettings: - port: number: 8000 tls: mode: "
"DISABLE EOF"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:289
msgid ""
"The port value in the peer authentication policy is the container’s port."
" The value the destination rule is the service’s port."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:291
msgid ""
"You can only use ``portLevelMtls`` if the port is bound to a service. "
"Istio ignores it otherwise."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:295
msgid "Policy precedence"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:297
msgid ""
"A workload-specific peer authentication policy takes precedence over a "
"namespace-wide policy. You can test this behavior if you add a policy to "
"disable mutual TLS for the ``httpbin.foo`` workload, for example. Note "
"that you’ve already created a namespace-wide policy that enables mutual "
"TLS for all services in namespace ``foo`` and observe that requests from "
"``sleep.legacy`` to ``httpbin.foo`` are failing (see above)."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:307
msgid ""
"“security.istio.io/v1beta1” kind: “PeerAuthentication” metadata: name: "
"“overwrite-example” namespace: “foo” spec: selector: matchLabels: app: "
"httpbin mtls: mode: DISABLE EOF"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:311
msgid "and destination rule:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:316
msgid ""
"“networking.istio.io/v1alpha3” kind: “DestinationRule” metadata: name: "
"“overwrite-example” spec: host: httpbin.foo.svc.cluster.local "
"trafficPolicy: tls: mode: DISABLE EOF"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:320
msgid ""
"Re-running the request from ``sleep.legacy``, you should see a success "
"return code again (200), confirming service-specific policy overrides the"
" namespace-wide policy."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:327
msgid ""
"legacy -o jsonpath={.items..metadata.name}) -c sleep -n legacy – curl "
"http://httpbin.foo:8000/ip -s -o /dev/null -w “%{http_code}:raw-"
"latex:`\\n`” 200"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:332
msgid "Cleanup part 2"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:334
msgid "Remove policies and destination rules created in the above steps:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:339
msgid ""
"overwrite-example -n foo $ kubectl delete peerauthentication httpbin -n "
"bar $ kubectl delete destinationrules default overwrite-example -n foo $ "
"kubectl delete destinationrules httpbin -n bar"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:344
msgid "End-user authentication"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:346
#, python-format
msgid ""
"To experiment with this feature, you need a valid JWT. The JWT must "
"correspond to the JWKS endpoint you want to use for the demo. This "
"tutorial use the test token `JWT test "
"<%7B%7B%3C%20github_file%20%3E%7D%7D/security/tools/jwt/samples/demo.jwt>`_"
" and `JWKS endpoint "
"<%7B%7B%3C%20github_file%20%3E%7D%7D/security/tools/jwt/samples/jwks.json>`_"
" from the Istio code base."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:354
msgid ""
"Also, for convenience, expose ``httpbin.foo`` via ``ingressgateway`` (for"
" more details, see the `ingress task </docs/tasks/traffic-"
"management/ingress/>`_)."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:361
msgid ""
"networking.istio.io/v1alpha3 kind: Gateway metadata: name: httpbin-"
"gateway namespace: foo spec: selector: istio: ingressgateway # use Istio "
"default gateway implementation servers: - port: number: 80 name: http "
"protocol: HTTP hosts: - \"*\" EOF"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:369
msgid ""
"networking.istio.io/v1alpha3 kind: VirtualService metadata: name: httpbin"
" namespace: foo spec: hosts: - \"*\" gateways: - httpbin-gateway http: - "
"route: - destination: port: number: 8000 host: "
"httpbin.foo.svc.cluster.local EOF"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:374
msgid "Get ingress IP"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:379
msgid ""
"service istio-ingressgateway -o "
"jsonpath=‘{.status.loadBalancer.ingress[0].ip}’)"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:382
msgid "And run a test query"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:387
#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:415
#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:519
msgid "“%{http_code}:raw-latex:`\\n`” 200"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:389
msgid ""
"Now, add a request authentication policy that requires end-user JWT for "
"the ingress gateway."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:395
msgid ""
"“security.istio.io/v1beta1” kind: “RequestAuthentication” metadata: name:"
" “jwt-example” namespace: istio-system spec: selector: matchLabels: "
"istio: ingressgateway jwtRules: - issuer: “testing@secure.istio.io” "
"jwksUri: “{{< github_file >}}/security/tools/jwt/samples/jwks.json” EOF"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:401
msgid ""
"Apply the policy to the namespace of the workload it selects, "
"``ingressgateway`` in this case. The namespace you need to specify is "
"then ``istio-system``."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:405
#, python-format
msgid ""
"If you provide a token in the authorization header, its implicitly "
"default location, Istio validates the token using the `public key set "
"<%7B%7B%3C%20github_file%20%3E%7D%7D/security/tools/jwt/samples/jwks.json>`_,"
" and rejects requests if the bearer token is invalid. However, requests "
"without tokens are accepted. To observe this behavior, retry the request "
"without a token, with a bad token, and with a valid token:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:420
msgid ""
"$INGRESS_HOST/headers -s -o /dev/null -w “%{http_code}:raw-latex:`\\n`” "
"401"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:426
msgid ""
">}}/security/tools/jwt/samples/demo.jwt -s) $ curl –header "
"“Authorization: Bearer $TOKEN” $INGRESS_HOST/headers -s -o /dev/null -w "
"“%{http_code}:raw-latex:`\\n`” 200"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:430
#, python-format
msgid ""
"To observe other aspects of JWT validation, use the script ```gen-"
"jwt.py`` <%7B%7B%3C%20github_tree%20%3E%7D%7D/security/tools/jwt/samples"
"/gen-jwt.py>`_ to generate new tokens to test with different issuer, "
"audiences, expiry date, etc. The script can be downloaded from the Istio "
"repository:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:438
msgid ">}}/security/tools/jwt/samples/gen-jwt.py $ chmod +x gen-jwt.py"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:440
msgid "You also need the ``key.pem`` file:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:445
msgid ">}}/security/tools/jwt/samples/key.pem"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:449
msgid "Download the"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:450
msgid ""
"`jwcrypto <https://pypi.org/project/jwcrypto>`_ library, if you haven’t "
"installed it on your system."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:453
msgid ""
"For example, the command below creates a token that expires in 5 seconds."
" As you see, Istio authenticates requests using that token successfully "
"at first but rejects them after 5 seconds:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:460
msgid ""
"``seq 1 10``; do curl –header “Authorization: Bearer $TOKEN” "
"$INGRESS_HOST/headers -s -o /dev/null -w “%{http_code}:raw-latex:`\\n`”; "
"sleep 1; done 200 200 200 200 200 401 401 401 401 401"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:464
msgid ""
"You can also add a JWT policy to an ingress gateway (e.g., service "
"``istio-ingressgateway.istio-system.svc.cluster.local``). This is often "
"used to define a JWT policy for all services bound to the gateway, "
"instead of for individual services."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:470
msgid "Require a valid token"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:472
msgid ""
"To reject requests without valid tokens, add an authorization policy with"
" a rule specifying a ``DENY`` action for requests without request "
"principals, shown as ``notRequestPrincipals: [\"*\"]`` in the following "
"example. Request principals are available only when valid JWT tokens are "
"provided. The rule therefore denies requests without valid tokens."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:481
msgid ""
"“security.istio.io/v1beta1” kind: “AuthorizationPolicy” metadata: name: "
"“frontend-ingress” namespace: istio-system spec: selector: matchLabels: "
"istio: ingressgateway action: DENY rules: - from: - source: "
"notRequestPrincipals: [\"*\"] EOF"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:486
msgid ""
"Retry the request without a token. The request now fails with error code "
"``403``:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:492
#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:514
msgid "“%{http_code}:raw-latex:`\\n`” 403"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:495
msgid "Require valid tokens per-path"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:497
msgid ""
"To refine authorization with a token requirement per host, path, or "
"method, change the authorization policy to only require JWT on "
"``/headers``. When this authorization rule takes effect, requests to "
"``$INGRESS_HOST/headers`` fail with the error code ``403``. Requests to "
"all other paths succeed, for example ``$INGRESS_HOST/ip``."
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:506
msgid ""
"“security.istio.io/v1beta1” kind: “AuthorizationPolicy” metadata: name: "
"“frontend-ingress” namespace: istio-system spec: selector: matchLabels: "
"istio: ingressgateway action: DENY rules: - from: - source: "
"notRequestPrincipals: [\"*\"] to: - operation: paths: [“/headers”] EOF"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:522
msgid "Cleanup part 3"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:524
msgid "Remove authentication policy:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:529
msgid "requestauthentication jwt-example"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:531
msgid "Remove authorization policy:"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:536
msgid "frontend-ingress"
msgstr ""

#: ../../source/docs/tasks/security/authentication/authn-policy/index.rst:538
msgid ""
"If you are not planning to explore any follow-on tasks, you can remove "
"all resources simply by deleting test namespaces."
msgstr ""

