# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, BandCamp
# This file is distributed under the same license as the istio-docs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: istio-docs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-03-22 10:08+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../../source/docs/concepts/security/index.rst:2
msgid "Security"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:4
msgid ""
"Breaking down a monolithic application into atomic services offers "
"various benefits, including better agility, better scalability and better"
" ability to reuse services. However, microservices also have particular "
"security needs:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:9
msgid ""
"To defend against the man-in-the-middle attack, they need traffic "
"encryption."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:12
msgid ""
"To provide flexible service access control, they need mutual TLS and "
"fine-grained access policies."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:15
msgid "To audit who did what at what time, they need auditing tools."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:17
msgid ""
"Istio Security tries to provide a comprehensive security solution to "
"solve all these issues."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:20
msgid ""
"This page gives an overview on how you can use Istio security features to"
" secure your services, wherever you run them. In particular, Istio "
"security mitigates both insider and external threats against your data, "
"endpoints, communication and platform."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:29
msgid ""
"The Istio security features provide strong identity, powerful policy, "
"transparent TLS encryption, and authentication, authorization and audit "
"(AAA) tools to protect your services and data. The goals of Istio "
"security are:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:34
msgid ""
"**Security by default**: no changes needed for application code and "
"infrastructure"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:37
msgid ""
"**Defense in depth**: integrate with existing security systems to provide"
" multiple layers of defense"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:40
msgid "**Zero-trust network**: build security solutions on untrusted networks"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:43
msgid ""
"Visit our `Mutual TLS Migration docs </docs/tasks/security/authentication"
"/mtls-migration/>`_ to start using Istio security features with your "
"deployed services. Visit our `Security Tasks </docs/tasks/security/>`_ "
"for detailed instructions to use the security features."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:50
msgid "High-level architecture"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:52
msgid "Security in Istio involves multiple components:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:54
msgid "**Citadel** for key and certificate management"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:56
msgid ""
"**Sidecar and perimeter proxies** to implement secure communication "
"between clients and servers"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:59
msgid ""
"**Pilot** to distribute `authentication policies </docs/concepts/security"
"/#authentication-policies>`_ and `secure naming information "
"</docs/concepts/security/#secure-naming>`_ to the proxies"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:65
msgid "**Mixer** to manage authorization and auditing"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:72
msgid ""
"In the following sections, we introduce the Istio security features in "
"detail."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:76
msgid "Istio identity"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:78
msgid ""
"Identity is a fundamental concept of any security infrastructure. At the "
"beginning of a service-to-service communication, the two parties must "
"exchange credentials with their identity information for mutual "
"authentication purposes. On the client side, the server’s identity is "
"checked against the `secure naming </docs/concepts/security/#secure-"
"naming>`_ information to see if it is an authorized runner of the "
"service. On the server side, the server can determine what information "
"the client can access based on the `authorization policies "
"</docs/concepts/security/#authorization-policy>`_, audit who accessed "
"what at what time, charge clients based on the services they used, and "
"reject any clients who failed to pay their bill from accessing the "
"services."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:92
msgid ""
"In the Istio identity model, Istio uses the first-class service identity "
"to determine the identity of a service. This gives great flexibility and "
"granularity to represent a human user, an individual service, or a group "
"of services. On platforms that do not have such identity available, Istio"
" can use other identities that can group service instances, such as "
"service names."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:99
msgid "Istio service identities on different platforms:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:101
msgid "**Kubernetes**: Kubernetes service account"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:103
msgid "**GKE/GCE**: may use GCP service account"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:105
msgid "**GCP**: GCP service account"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:107
msgid "**AWS**: AWS IAM user/role account"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:109
msgid ""
"**On-premises (non-Kubernetes)**: user account, custom service account, "
"service name, Istio service account, or GCP service account. The custom "
"service account refers to the existing service account just like the "
"identities that the customer’s Identity Directory manages."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:116
msgid "Istio security vs SPIFFE"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:118
msgid ""
"The `SPIFFE <https://spiffe.io/>`_ standard provides a specification for "
"a framework capable of bootstrapping and issuing identities to services "
"across heterogeneous environments."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:122
msgid ""
"Istio and SPIFFE share the same identity document: `SVID "
"<https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE-ID.md>`_ "
"(SPIFFE Verifiable Identity Document). For example, in Kubernetes, the "
"X.509 certificate has the URI field in the format of "
"``spiffe://<domain>/ns/<namespace>/sa/<serviceaccount>``. This enables "
"Istio services to establish and accept connections with other SPIFFE-"
"compliant systems."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:130
msgid ""
"Istio security and `SPIRE <https://spiffe.io/spire/>`_, which is the "
"implementation of SPIFFE, differ in the PKI implementation details. Istio"
" provides a more comprehensive security solution, including "
"authentication, authorization, and auditing."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:136
msgid "PKI"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:138
msgid ""
"The Istio PKI is built on top of Istio Citadel and securely provisions "
"strong identities to every workload. Istio uses X.509 certificates to "
"carry the identities in `SPIFFE <https://spiffe.io/>`_ format. The PKI "
"also automates the key & certificate rotation at scale."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:143
msgid ""
"Istio supports services running on both Kubernetes pods and on-premises "
"machines. Currently we use different certificate key provisioning "
"mechanisms for each scenario."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:148
msgid "Kubernetes scenario"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:150
msgid ""
"Citadel watches the Kubernetes ``apiserver``, creates a SPIFFE "
"certificate and key pair for each of the existing and new service "
"accounts. Citadel stores the certificate and key pairs as `Kubernetes "
"secrets <https://kubernetes.io/docs/concepts/configuration/secret/>`_."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:155
msgid ""
"When you create a pod, Kubernetes mounts the certificate and key pair to "
"the pod according to its service account via `Kubernetes secret volume "
"<https://kubernetes.io/docs/concepts/storage/volumes/#secret>`_."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:159
msgid ""
"Citadel watches the lifetime of each certificate, and automatically "
"rotates the certificates by rewriting the Kubernetes secrets."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:162
msgid ""
"Pilot generates the `secure naming </docs/concepts/security/#secure-"
"naming>`_ information, which defines what service account or accounts can"
" run a certain service. Pilot then passes the secure naming information "
"to the sidecar Envoy."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:168
msgid "On-premises machines scenario"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:170
msgid ""
"Citadel creates a gRPC service to take `Certificate Signing Requests "
"<https://en.wikipedia.org/wiki/Certificate_signing_request>`_ (CSRs)."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:174
msgid ""
"The Istio Agent generates a private key and CSR, and sends the CSR with "
"its credentials to Citadel for signing."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:177
msgid ""
"Citadel validates the credentials carried with the CSR, and signs the CSR"
" to generate the certificate."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:180
msgid ""
"The Istio Agent sends both the certificate received from Citadel and the "
"private key to Envoy."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:183
#: ../../source/docs/concepts/security/index.rst:217
msgid ""
"The above CSR process repeats periodically for certificate and key "
"rotation."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:187
msgid "The Istio Agent in Kubernetes"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:189
msgid ""
"Istio provides the option of using the Istio Agent in Kubernetes for "
"certificate and key provisioning, as shown in the figure below. Note that"
" the identity provisioning flow for on-premises machines will be similar "
"in the near future, we only describe the Kubernetes scenario here."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:200
msgid "The flow goes as follows:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:202
msgid "Citadel creates a gRPC service to take CSR requests."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:204
msgid ""
"Envoy sends a certificate and key request via Envoy secret discovery "
"service (SDS) API."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:207
msgid ""
"Upon receiving the SDS request, the Istio Agent creates the private key "
"and CSR before sending the CSR with its credentials to Citadel for "
"signing."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:211
msgid ""
"Citadel validates the credentials carried in the CSR and signs the CSR to"
" generate the certificate."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:214
msgid ""
"The Istio Agent sends the certificate received from Citadel and the "
"private key to Envoy via the Envoy SDS API."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:222
msgid "Use the Istio Agent debug endpoint to view the secrets an"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:223
msgid ""
"Istio Agent is actively serving to its client proxies. Navigate to "
"``/debug/sds/workload`` on the agent’s port ``8080`` to dump active "
"workload secrets, or ``/debug/sds/gateway`` to dump active gateway "
"secrets."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:229
msgid "Authentication"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:231
msgid "Istio provides two types of authentication:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:233
msgid ""
"**Transport authentication**, also known as **service-to-service "
"authentication**: verifies the direct client making the connection. Istio"
" offers `mutual TLS "
"<https://en.wikipedia.org/wiki/Mutual_authentication>`_ as a full stack "
"solution for transport authentication. You can easily turn on this "
"feature without requiring service code changes. This solution:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:241
msgid ""
"Provides each service with a strong identity representing its role to "
"enable interoperability across clusters and clouds."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:243
msgid ""
"Secures service-to-service communication and end-user-to-service "
"communication."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:245
msgid ""
"Provides a key management system to automate key and certificate "
"generation, distribution, and rotation."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:248
msgid ""
"**Origin authentication**, also known as **end-user authentication**: "
"verifies the original client making the request as an end-user or device."
" Istio enables request-level authentication with JSON Web Token (JWT) "
"validation and a streamlined developer experience for open source OpenID "
"Connect provider `ORY Hydra <https://www.ory.sh>`_, `Keycloak "
"<https://www.keycloak.org>`_, `Auth0 <https://auth0.com/>`_, `Firebase "
"Auth <https://firebase.google.com/docs/auth/>`_, `Google Auth "
"<https://developers.google.com/identity/protocols/OpenIDConnect>`_, and "
"custom auth."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:260
msgid ""
"In both cases, Istio stores the authentication policies in the ``Istio "
"config store`` via a custom Kubernetes API. Pilot keeps them up-to-date "
"for each proxy, along with the keys where appropriate. Additionally, "
"Istio supports authentication in permissive mode to help you understand "
"how a policy change can affect your security posture before it becomes "
"effective."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:268
msgid "Mutual TLS authentication"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:270
msgid ""
"Istio tunnels service-to-service communication through the client side "
"and server side `Envoy proxies <https://envoyproxy.github.io/envoy/>`_. "
"For a client to call a server with mutual TLS authentication:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:274
msgid ""
"Istio re-routes the outbound traffic from a client to the client’s local "
"sidecar Envoy."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:277
msgid ""
"The client side Envoy starts a mutual TLS handshake with the server side "
"Envoy. During the handshake, the client side Envoy also does a `secure "
"naming </docs/concepts/security/#secure-naming>`_ check to verify that "
"the service account presented in the server certificate is authorized to "
"run the target service."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:283
msgid ""
"The client side Envoy and the server side Envoy establish a mutual TLS "
"connection, and Istio forwards the traffic from the client side Envoy to "
"the server side Envoy."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:287
msgid ""
"After authorization, the server side Envoy forwards the traffic to the "
"server service through local TCP connections."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:291
msgid "Permissive mode"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:293
msgid ""
"Istio mutual TLS has a permissive mode, which allows a service to accept "
"both plaintext traffic and mutual TLS traffic at the same time. This "
"feature greatly improves the mutual TLS onboarding experience."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:297
msgid ""
"Many non-Istio clients communicating with a non-Istio server presents a "
"problem for an operator who wants to migrate that server to Istio with "
"mutual TLS enabled. Commonly, the operator cannot install an Istio "
"sidecar for all clients at the same time or does not even have the "
"permissions to do so on some clients. Even after installing the Istio "
"sidecar on the server, the operator cannot enable mutual TLS without "
"breaking existing communications."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:305
msgid ""
"With the permissive mode enabled, the server accepts both plaintext and "
"mutual TLS traffic. The mode provides great flexibility for the on-"
"boarding process. The server’s installed Istio sidecar takes mutual TLS "
"traffic immediately without breaking existing plaintext traffic. As a "
"result, the operator can gradually install and configure the client’s "
"Istio sidecars to send mutual TLS traffic. Once the configuration of the "
"clients is complete, the operator can configure the server to mutual TLS "
"only mode. For more information, visit the `Mutual TLS Migration tutorial"
" </docs/tasks/security/authentication/mtls-migration>`_."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:316
msgid "Secure naming"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:318
msgid ""
"The secure naming information contains *N-to-N* mappings from the server "
"identities, which are encoded in certificates, to the service names that "
"are referred by discovery service or DNS. A mapping from identity ``A`` "
"to service name ``B`` means “``A`` is allowed and authorized to run "
"service ``B``”. Pilot watches the Kubernetes ``apiserver``, generates the"
" secure naming information, and distributes it securely to the sidecar "
"Envoys. The following example explains why secure naming is critical in "
"authentication."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:327
msgid ""
"Suppose the legitimate servers that run the service ``datastore`` only "
"use the ``infra-team`` identity. A malicious user has certificate and key"
" for the ``test-team`` identity. The malicious user intends to "
"impersonate the service to inspect the data sent from the clients. The "
"malicious user deploys a forged server with the certificate and key for "
"the ``test-team`` identity. Suppose the malicious user successfully "
"hijacked (through DNS spoofing, BGP/route hijacking, ARP spoofing, etc.) "
"the traffic sent to the ``datastore`` and redirected it to the forged "
"server."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:337
msgid ""
"When a client calls the ``datastore`` service, it extracts the ``test-"
"team`` identity from the server’s certificate, and checks whether ``test-"
"team`` is allowed to run ``datastore`` with the secure naming "
"information. The client detects that ``test-team`` is **not** allowed to "
"run the ``datastore`` service and the authentication fails."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:343
msgid ""
"Secure naming is able to protect against general network hijackings for "
"HTTPS traffic. It can also protect TCP traffic from general network "
"hijackings except for DNS spoofing. It would fail to work for TCP traffic"
" if the attacker hijacks the DNS and modifies the IP address of the "
"destination. This is because TCP traffic does not contain the hostname "
"information and we can only rely on the IP address for routing. And this "
"DNS hijack can happen even before the client-side Envoy receives the "
"traffic."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:353
msgid "Authentication architecture"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:355
msgid ""
"You can specify authentication requirements for services receiving "
"requests in an Istio mesh using authentication policies. The mesh "
"operator uses ``.yaml`` files to specify the policies. The policies are "
"saved in the Istio configuration storage once deployed. Pilot, the Istio "
"controller, watches the configuration storage. Upon any policy changes, "
"Pilot translates the new policy to the appropriate configuration telling "
"the Envoy sidecar proxy how to perform the required authentication "
"mechanisms. Pilot may fetch the public key and attach it to the "
"configuration for JWT validation. Alternatively, Pilot provides the path "
"to the keys and certificates the Istio system manages and installs them "
"to the application pod for mutual TLS. You can find more info in the `PKI"
" section </docs/concepts/security/#pki>`_. Istio sends configurations to "
"the targeted endpoints asynchronously. Once the proxy receives the "
"configuration, the new authentication requirement takes effect "
"immediately on that pod."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:371
msgid ""
"Client services, those that send requests, are responsible for following "
"the necessary authentication mechanism. For origin authentication (JWT), "
"the application is responsible for acquiring and attaching the JWT "
"credential to the request. For mutual TLS, Istio provides a `destination "
"rule </docs/concepts/traffic-management/#destination-rules>`_. The "
"operator can use the destination rule to instruct client proxies to make "
"initial connections using TLS with the certificates expected on the "
"server side. You can find out more about how mutual TLS works in Istio in"
" `Mutual TLS authentication </docs/concepts/security/#mutual-tls-"
"authentication>`_."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:387
msgid ""
"Istio outputs identities with both types of authentication, as well as "
"other claims in the credential if applicable, to the next layer: "
"`authorization </docs/concepts/security/#authorization>`_. Additionally, "
"operators can specify which identity, either from transport or origin "
"authentication, should Istio use as ‘the principal’."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:394
msgid "Authentication policies"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:396
msgid ""
"This section provides more details about how Istio authentication "
"policies work. As you’ll remember from the `Architecture section "
"</docs/concepts/security/#authentication-architecture>`_, authentication "
"policies apply to requests that a service **receives**. To specify "
"client-side authentication rules in mutual TLS, you need to specify the "
"``TLSSettings`` in the ``DestinationRule``. You can find more information"
" in our `TLS settings reference docs </docs/reference/config/networking"
"/destination-rule/#TLSSettings>`_. Like other Istio configuration, you "
"can specify authentication policies in ``.yaml`` files. You deploy "
"policies using ``kubectl``."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:407
msgid ""
"The following example authentication policy specifies that transport "
"authentication for the ``reviews`` service must use mutual TLS:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:413
msgid ""
"“Policy” metadata: name: “reviews” spec: targets: - name: reviews peers: "
"- mtls: {}"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:417
msgid "Policy storage scope"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:419
msgid ""
"Istio can store authentication policies in namespace-scope or mesh-scope "
"storage:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:422
msgid ""
"Mesh-scope policy is specified with a value of ``MeshPolicy`` for the "
"``kind`` field and the name ``\"default\"``. For example:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:428
msgid "kind: “MeshPolicy” metadata: name: “default” spec: peers: - mtls: {}"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:431
msgid ""
"Namespace-scope policy is specified with a value of ``\"Policy\"`` for "
"the ``kind`` field and a specified namespace. If unspecified, the default"
" namespace is used. For example for namespace ``ns1``:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:438
msgid ""
"kind: “Policy” metadata: name: “default” namespace: “ns1” spec: peers: - "
"mtls: {}"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:441
msgid ""
"Policies in the namespace-scope storage can only affect services in the "
"same namespace. Policies in mesh-scope can affect all services in the "
"mesh. To prevent conflict and misuse, only one policy can be defined in "
"mesh-scope storage. That policy must be named ``default`` and have an "
"empty ``targets:`` section. You can find more information on our `target "
"selectors section </docs/concepts/security/#target-selectors>`_."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:448
msgid ""
"Kubernetes currently implements the Istio configuration on Custom "
"Resource Definitions (CRDs). These CRDs correspond to namespace-scope and"
" cluster-scope ``CRDs`` and automatically inherit access protection via "
"the Kubernetes RBAC. You can read more on the `Kubernetes CRD "
"documentation <https://kubernetes.io/docs/concepts/extend-kubernetes/api-"
"extension/custom-resources/#customresourcedefinitions>`_"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:455
msgid "Target selectors"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:457
msgid ""
"An authentication policy’s targets specify the service or services to "
"which the policy applies. The following example shows a ``targets:`` "
"section specifying that the policy applies to:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:461
msgid "The ``product-page`` service on any port."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:462
msgid "The reviews service on port ``9000``."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:467
msgid "number: 9000"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:469
msgid ""
"If you don’t provide a ``targets:`` section, Istio matches the policy to "
"all services in the storage scope of the policy. Thus, the ``targets:`` "
"section can help you specify the scope of the policies:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:473
msgid ""
"Mesh-wide policy: A policy defined in the mesh-scope storage with no "
"target selector section. There can be at most **one** mesh-wide policy "
"**in the mesh**."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:477
msgid ""
"Namespace-wide policy: A policy defined in the namespace-scope storage "
"with name ``default`` and no target selector section. There can be at "
"most **one** namespace-wide policy **per namespace**."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:481
msgid ""
"Service-specific policy: a policy defined in the namespace-scope storage,"
" with non-empty target selector section. A namespace can have **zero, "
"one, or many** service-specific policies."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:485
msgid ""
"For each service, Istio applies the narrowest matching policy. The order "
"is: **service-specific > namespace-wide > mesh-wide**. If more than one "
"service-specific policy matches a service, Istio selects one of them at "
"random. Operators must avoid such conflicts when configuring their "
"policies."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:491
msgid ""
"To enforce uniqueness for mesh-wide and namespace-wide policies, Istio "
"accepts only one authentication policy per mesh and one authentication "
"policy per namespace. Istio also requires mesh-wide and namespace-wide "
"policies to have the specific name ``default``."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:496
msgid ""
"If a service has no matching policies, both transport authentication and "
"origin authentication are disabled."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:500
msgid "Transport authentication"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:502
msgid ""
"The ``peers:`` section defines the authentication methods and associated "
"parameters supported for transport authentication in a policy. The "
"section can list more than one method and only one method must be "
"satisfied for the authentication to pass. However, as of the Istio 0.7 "
"release, the only transport authentication method currently supported is "
"mutual TLS."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:509
msgid ""
"The following example shows the ``peers:`` section enabling transport "
"authentication using mutual TLS."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:516
msgid ""
"The mutual TLS setting has an optional ``mode`` parameter that defines "
"the strictness of the peer transport authentication. These modes are "
"documented in the `Authentication Policy reference document "
"</docs/reference/config/security/istio.authentication.v1alpha1"
"/#MutualTls-Mode>`_."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:521
msgid ""
"The default mutual TLS mode is ``STRICT``. Therefore, ``mode: STRICT`` is"
" equivalent to all of the following:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:524
msgid "``- mtls: {}``"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:525
msgid "``- mtls:``"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:526
msgid "``- mtls: null``"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:528
msgid ""
"When you do not specify a mutual TLS mode, peers cannot use transport "
"authentication, and Istio rejects mutual TLS connections bound for the "
"sidecar. At the application layer, services may still handle their own "
"mutual TLS sessions."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:534
msgid "Origin authentication"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:536
msgid ""
"The ``origins:`` section defines authentication methods and associated "
"parameters supported for origin authentication. Istio only supports JWT "
"origin authentication. You can specify allowed JWT issuers, and enable or"
" disable JWT authentication for a specific path. If all JWTs are disabled"
" for a request path, authentication also passes as if there is none "
"defined. Similar to peer authentication, only one of the listed methods "
"must be satisfied for the authentication to pass."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:544
msgid ""
"The following example policy specifies an ``origins:`` section for origin"
" authentication that accepts JWTs issued by Google. JWT authentication "
"for path ``/health`` is disabled."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:551
msgid ""
"jwksUri: “https://www.googleapis.com/oauth2/v3/certs” trigger_rules: - "
"excluded_paths: - exact: /health"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:555
msgid "Principal binding"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:557
msgid ""
"The principal binding key-value pair defines the principal authentication"
" for a policy. By default, Istio uses the authentication configured in "
"the ``peers:`` section. If no authentication is configured in the "
"``peers:`` section, Istio leaves the authentication unset. Policy writers"
" can override this behavior with the ``USE_ORIGIN`` value. This value "
"configures Istio to use the origin’s authentication as the principal "
"authentication instead. In the future, we will support conditional "
"binding, for example: ``USE_PEER`` when peer is X, otherwise "
"``USE_ORIGIN``."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:567
msgid ""
"The following example shows the ``principalBinding`` key with a value of "
"``USE_ORIGIN``:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:575
msgid "Updating authentication policies"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:577
msgid ""
"You can change an authentication policy at any time and Istio pushes the "
"change to the endpoints almost in real time. However, Istio cannot "
"guarantee that all endpoints receive a new policy at the same time. The "
"following are recommendations to avoid disruption when updating your "
"authentication policies:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:583
msgid ""
"To enable or disable mutual TLS: Use a temporary policy with a ``mode:`` "
"key and a ``PERMISSIVE`` value. This configures receiving services to "
"accept both types of traffic: plaintext and TLS. Thus, no request is "
"dropped. Once all clients switch to the expected protocol, with or "
"without mutual TLS, you can replace the ``PERMISSIVE`` policy with the "
"final policy. For more information, visit the `Mutual TLS Migration "
"tutorial </docs/tasks/security/authentication/mtls-migration>`_."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:596
msgid ""
"For JWT authentication migration: requests should contain new JWT before "
"changing policy. Once the server side has completely switched to the new "
"policy, the old JWT, if there is any, can be removed. Client applications"
" need to be changed for these changes to work."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:602
msgid "Authorization"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:604
msgid ""
"Istio’s authorization feature provides mesh-level, namespace-level, and "
"workload-level access control on workloads in an Istio Mesh. It provides:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:608
msgid "**Workload-to-workload and end-user-to-workload authorization**."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:609
msgid ""
"**A Simple API**, it includes a single `AuthorizationPolicy CRD "
"</docs/reference/config/security/authorization-policy/>`_, which is easy "
"to use and maintain."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:610
msgid ""
"**Flexible semantics**, operators can define custom conditions on Istio "
"attributes."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:611
msgid ""
"**High performance**, as Istio authorization is enforced natively on "
"Envoy."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:612
msgid ""
"**High compatibility**, supports HTTP, HTTPS and HTTP2 natively, as well "
"as any plain TCP protocols."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:615
msgid "Authorization architecture"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:622
msgid ""
"The above diagram shows the basic Istio authorization architecture. "
"Operators specify Istio authorization policies using ``.yaml`` files."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:625
msgid ""
"Each Envoy proxy runs an authorization engine that authorizes requests at"
" runtime. When a request comes to the proxy, the authorization engine "
"evaluates the request context against the current authorization policies,"
" and returns the authorization result, ``ALLOW`` or ``DENY``."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:631
msgid "Implicit enablement"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:633
msgid ""
"There is no need to explicitly enable Istio’s authorization feature, you "
"just apply the ``AuthorizationPolicy`` on **workloads** to enforce access"
" control."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:637
msgid ""
"If no ``AuthorizationPolicy`` applies to a workload, no access control "
"will be enforced. In other words, all requests will be allowed."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:640
msgid ""
"If any ``AuthorizationPolicy`` applies to a workload, access to that "
"workload is denied by default, unless explicitly allowed by a rule "
"declared in the policy."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:644
msgid ""
"Currently ``AuthorizationPolicy`` only supports ``ALLOW`` action. This "
"means that if multiple authorization policies apply to the same workload,"
" the effect is additive."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:649
msgid "Authorization policy"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:651
msgid ""
"To configure an Istio authorization policy, you create an "
"`AuthorizationPolicy resource </docs/reference/config/security"
"/authorization-policy/>`_."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:653
msgid ""
"An authorization policy includes a selector and a list of rules. The "
"selector specifies the **target** that the policy applies to, while the "
"rules specify **who** is allowed to do **what** under which "
"**conditions**. Specifically:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:658
msgid ""
"**target** refers to the ``selector`` section in the "
"``AuthorizationPolicy``."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:660
msgid ""
"**who** refers to the ``from`` section in the ``rule`` of the "
"``AuthorizationPolicy``."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:662
msgid ""
"**what** refers to the ``to`` section in the ``rule`` of the "
"``AuthorizationPolicy``."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:664
msgid ""
"**conditions** refers to the ``when`` section in the ``rule`` of the "
"``AuthorizationPolicy``."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:667
msgid "Each rule has the following standard fields:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:669
msgid "**``from``**: A list of sources."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:670
msgid "**``to``**: A list of operations."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:671
msgid "**``when``**: A list of custom conditions."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:673
msgid ""
"The following example shows an ``AuthorizationPolicy`` that allows two "
"sources (service account ``cluster.local/ns/default/sa/sleep`` and "
"namespace ``dev``) to access the workloads with labels ``app: httpbin`` "
"and ``version: v1`` in namespace foo when the request is sent with a "
"valid JWT token."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:682
msgid ""
"AuthorizationPolicy metadata: name: httpbin namespace: foo spec: "
"selector: matchLabels: app: httpbin version: v1 rules: - from: - source: "
"principals: [“cluster.local/ns/default/sa/sleep”] - source: namespaces: "
"[“dev”] to: - operation: methods: [“GET”] when: - key: "
"request.auth.claims[iss] values: [“https://accounts.google.com”]"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:689
msgid "Policy Target"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:691
msgid ""
"Policy scope (target) is determined by ``metadata/namespace`` and an "
"optional ``selector``."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:694
msgid ""
"The ``metadata/namespace`` tells which namespace the policy applies to. "
"If set to the root namespace, the policy applies to all namespaces in a "
"mesh. The value of root namespace is configurable, and the default is "
"``istio-system``. If set to a normal namespace, the policy will only "
"apply to the specified namespace."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:700
msgid ""
"A workload ``selector`` can be used to further restrict where a policy "
"applies. The ``selector`` uses pod labels to select the target workload. "
"The workload selector contains a list of ``{key: value}`` pairs, where "
"the ``key`` is the name of the label. If not set, the authorization "
"policy will be applied to all workloads in the same namespace as the "
"authorization policy."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:707
msgid ""
"The following example policy ``allow-read`` allows ``\"GET\"`` and "
"``\"HEAD\"`` access to the workload with label ``app: products`` in the "
"``default`` namespace."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:714
msgid ""
"AuthorizationPolicy metadata: name: allow-read namespace: default spec: "
"selector: matchLabels: app: products rules: - to: - operation: methods: "
"[“GET”, “HEAD”]"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:719
msgid "Value matching"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:721
msgid ""
"Exact match, prefix match, suffix match, and presence match are supported"
" for most of the field with a few exceptions (e.g., the ``key`` field "
"under the ``when`` section, the ``ipBlocks`` under the ``source`` section"
" and the ``ports`` field under the ``to`` section only support exact "
"match)."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:727
msgid "**Exact match**. i.e., exact string match."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:728
msgid ""
"**Prefix match**. A string with an ending ``\"*\"``. For example, "
"``\"test.abc.*\"`` matches ``\"test.abc.com\"``, ``\"test.abc.com.cn\"``,"
" ``\"test.abc.org\"``, etc."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:731
msgid ""
"**Suffix match**. A string with a starting ``\"*\"``. For example, "
"``\"*.abc.com\"`` matches ``\"eng.abc.com\"``, ``\"test.eng.abc.com\"``, "
"etc."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:734
msgid ""
"**Presence match**. ``*`` is used to specify anything but not empty. You "
"can specify a field must be present using the format ``fieldname: "
"[\"*\"]``. This means that the field can match any value, but it cannot "
"be empty. Note that it is different from leaving a field unspecified, "
"which means anything including empty."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:740
msgid ""
"The following example policy allows access at paths with prefix "
"``\"/test/\"`` or suffix ``\"/info\"``."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:746
msgid ""
"AuthorizationPolicy metadata: name: tester namespace: default spec: "
"selector: matchLabels: app: products rules: - to: - operation: paths: "
"[“/test/*\", \"*/info”]"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:751
msgid "Allow-all and deny-all"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:753
msgid ""
"The example below shows a simple policy ``allow-all`` which allows full "
"access to all workloads in the ``default`` namespace."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:759
msgid ""
"AuthorizationPolicy metadata: name: allow-all namespace: default spec: "
"rules: - {}"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:762
msgid ""
"The example below shows a simple policy ``deny-all`` which denies access "
"to all workloads in the ``admin`` namespace."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:768
msgid "AuthorizationPolicy metadata: name: deny-all namespace: admin spec: {}"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:772
msgid "Custom conditions"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:774
msgid ""
"You can also use the ``when`` section to specify additional conditions. "
"For example, the following ``AuthorizationPolicy`` definition includes a "
"condition that ``request.headers[version]`` is either ``\"v1\"`` or "
"``\"v2\"``. In this case, the key is ``request.headers[version]``, which "
"is an entry in the Istio attribute ``request.headers``, which is a map."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:783
msgid ""
"AuthorizationPolicy metadata: name: httpbin namespace: foo spec: "
"selector: matchLabels: app: httpbin version: v1 rules: - from: - source: "
"principals: [“cluster.local/ns/default/sa/sleep”] to: - operation: "
"methods: [“GET”] when: - key: request.headers[version] values: [“v1”, "
"“v2”]"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:789
msgid ""
"The supported ``key`` values of a condition are listed in the `conditions"
" page </docs/reference/config/security/conditions/>`_."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:793
msgid "Authenticated and unauthenticated identity"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:795
msgid ""
"If you want to make a workload publicly accessible, you need to leave the"
" ``source`` section empty. This allows sources from **all (both "
"authenticated and unauthenticated)** users and workloads, for example:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:802
msgid ""
"AuthorizationPolicy metadata: name: httpbin namespace: foo spec: "
"selector: matchLabels: app: httpbin version: v1 rules: - to: - operation:"
" methods: [“GET”, “POST”]"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:806
msgid ""
"To allow only **authenticated** users, set ``principal`` to ``\"*\"`` "
"instead, for example:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:812
msgid ""
"AuthorizationPolicy metadata: name: httpbin namespace: foo spec: "
"selector: matchLabels: app: httpbin version: v1 rules: - from: - source: "
"principals: [\"*\"] to: - operation: methods: [“GET”, “POST”] {{< /text "
">}}"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:818
msgid "Using Istio authorization on plain TCP protocols"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:820
msgid ""
"Istio authorization supports workloads using any plain TCP protocols, "
"such as MongoDB. In this case, you configure the authorization policy in "
"the same way you did for the HTTP workloads. The difference is that "
"certain fields and conditions are only applicable to HTTP workloads. "
"These fields include:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:826
msgid ""
"The ``request_principals`` field in the source section of the "
"authorization policy object"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:828
msgid ""
"The ``hosts``, ``methods`` and ``paths`` fields in the operation section "
"of the authorization policy object"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:831
msgid ""
"The supported conditions are listed in the `conditions page "
"</docs/reference/config/security/conditions/>`_."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:834
msgid ""
"If you use any HTTP only fields for a TCP workload, Istio will ignore "
"HTTP only fields in the authorization policy."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:837
msgid ""
"Assuming you have a MongoDB service on port 27017, the following example "
"configures an authorization policy to only allow the ``bookinfo-"
"ratings-v2`` service in the Istio mesh to access the MongoDB workload."
msgstr ""

#: ../../source/docs/concepts/security/index.rst:845
msgid ""
"AuthorizationPolicy metadata: name: mongodb-policy namespace: default "
"spec: selector: matchLabels: app: mongodb rules: - from: - source: "
"principals: [“cluster.local/ns/default/sa/bookinfo-ratings-v2”] to: - "
"operation: ports: [“27017”]"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:851
msgid "Dependency on mutual TLS"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:853
msgid ""
"Istio uses mutual TLS to securely pass some information from the client "
"to the server. Mutual TLS must be enabled before using any of the "
"following fields in the authorization policy:"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:857
msgid "the ``principals`` field under the ``source`` section"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:858
msgid "the ``namespaces`` field under the ``source`` section"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:859
msgid "the ``source.principal`` custom condition"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:860
msgid "the ``source.namespace`` custom condition"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:861
msgid "the ``connection.sni`` custom condition"
msgstr ""

#: ../../source/docs/concepts/security/index.rst:863
msgid ""
"Mutual TLS is not required if you don’t use any of the above fields in "
"the authorization policy."
msgstr ""

